<!DOCTYPE html>
<html>
<head>
    <title>Smart Home Control Panel</title>
    <style>
        body { background-color:#FFD0D0; font-family: sans-serif; }
        p, button, input { font-size: 16px; }
        #status_display {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ccc;
            background-color: #f9f9f9;
            border-radius: 5px;
        }
        .loading {
            color: #888;
            font-style: italic;
        }
        .status-complete {
            font-weight: bold;
            color: #008800;
        }
        .status-pending {
            color: #888;
        }
    </style>
</head>
<body id="body">

    <h1>Smart Home Control Panel</h1>
    <p>
        Welcome back, please connect your hub first.
    </p>

    <button onclick="connect()">Connect to hub</button>
    <button onclick="disconnect()">Disconnect from hub</button>

    <br><br>
    <div id="status_display">
        <h3>HOME STATUSğŸ¡<span id="status_loading" class="loading"></span></h3>
        <p id="status_lightsensor_text" class="status-pending">Light Sensorï¼šUnknown</p>
        <p id="status_aircon_text" class="status-pending">ACï¼šUNKNOWN</p>
        <p id="status_lightcontrol_text" class="status-pending">LIGHTï¼šUNKNOWN</p>
    </div>

    <p>Light ğŸ’¡</p>
    <p>
    <button onclick="setRxText('SET lightcontrol 1')">TURN ONğŸ”›</button>
    <button onclick="setRxText('SET lightcontrol 0')">TURN OFF ğŸ“´</button>
    </p>
    
    <p>Air conditioner</p>
    <p>
    <button onclick="setRxText('SET aircon 1')">TURN ONğŸ”›</button>
    <button onclick="setRxText('SET aircon 0')">TURN OFF ğŸ“´</button>
    </p>
    <h2>Transmitting Area</h2>
    <input type="text" id="rxText" maxlength="19">
    <button onclick="writeRx()">CONFIRM COMMAND</button>
    
    <br>
    <button onclick="refreshStates()">Refresh Status</button>

    <h2>Received Data<button onclick="clearTx()">ClearğŸ—‘ï¸</button></h2>
    <p id="tx" style="font-family:'Courier New',Courier,monospace"></p>

    <h2>log <button onclick="clearLog()">ClearğŸ—‘ï¸</button></h2>
    <p id="log" style="font-family:'Courier New',Courier,monospace"></p>

    <script>
    /**
     * åŒ…å«micro:bitæ‰€æœ‰æœå‹™å’Œç‰¹å¾µçš„è—ç‰™UUIDçš„å°è±¡
     */
    var microbitUuid = {
        /**
         * æœå‹™
         */
        genericAccess:                             ["00001800-0000-1000-8000-00805f9b34fb", "ä¸€èˆ¬è¨ªå•"],
        genericAttribute:                            ["00001801-0000-1000-8000-00805f9b34fb", "ä¸€èˆ¬å±¬æ€§"],
        deviceInformation:                           ["0000180a-0000-1000-8000-00805f9b34fb", "è¨­å‚™ä¿¡æ¯"],
        accelerometerService:                        ["e95d0753-251d-470a-a062-fa1922dfa9a8", "åŠ é€Ÿåº¦è¨ˆæœå‹™"],
        magnetometerService:                         ["e95df2d8-251d-470a-a062-fa1922dfa9a8", "ç£åŠ›è¨ˆæœå‹™"],
        buttonService:                               ["e95d9882-251d-470a-a062-fa1922dfa9a8", "æŒ‰éˆ•æœå‹™"],
        ioPinService:                                ["e95d127b-251d-470a-a062-fa1922dfa9a8", "IOå¼•è…³æœå‹™"],
        ledService:                                  ["e95dd91d-251d-470a-a062-fa1922dfa9a8", "LEDæœå‹™"],
        eventService:                                ["e95d93af-251d-470a-a062-fa1922dfa9a8", "äº‹ä»¶æœå‹™"],
        dfuControlService:                           ["e95d93b0-251d-470a-a062-fa1922dfa9a8", "DFUæ§åˆ¶æœå‹™"],
        temperatureService:                          ["e95d6100-251d-470a-a062-fa1922dfa9a8", "æº«åº¦æœå‹™"],
        uartService:                                 ["6e400001-b5a3-f393-e0a9-e50e24dcca9e", "UARTæœå‹™"],
        /**
         * ç‰¹å¾µ
         */
        deviceName:                                  ["00002a00-0000-1000-8000-00805f9b34fb", "è¨­å‚™åç¨±"],
        appearance:                                  ["00002a01-0000-1000-8000-00805f9b34fb", "å¤–è§€"],
        peripheralPreferredConnectionParameters:     ["00002a04-0000-1000-8000-00805f9b34fb", "å¤–è¨­é¦–é¸é€£æ¥åƒæ•¸"],
        serviceChanged:                              ["00002a05-0000-1000-8000-00805f9b34fb", "æœå‹™å·²æ›´æ”¹"],
        modelNumberString:                           ["00002a24-0000-1000-8000-00805f9b34fb", "å‹è™Ÿå­—ç¬¦ä¸²"],
        serialNumberString:                          ["00002a25-0000-1000-8000-00805f9b34fb", "åºåˆ—è™Ÿå­—ç¬¦ä¸²"],
        hardwareRevisionString:                      ["00002a27-0000-1000-8000-00805f9b34fb", "ç¡¬ä»¶ç‰ˆæœ¬å­—ç¬¦ä¸²"],
        firmwareRevisionString:                      ["00002a26-0000-1000-8000-00805f9b34fb", "å›ºä»¶ç‰ˆæœ¬å­—ç¬¦ä¸²"],
        manufacturerNameString:                      ["00002a29-0000-1000-8000-00805f9b34fb", "è£½é€ å•†åç¨±å­—ç¬¦ä¸²"],
        accelerometerData:                           ["e95dca4b-251d-470a-a062-fa1922dfa9a8", "åŠ é€Ÿåº¦è¨ˆæ•¸æ“š"],
        accelerometerPeriod:                         ["e95dfb24-251d-470a-a062-fa1922dfa9a8", "åŠ é€Ÿåº¦è¨ˆé€±æœŸ"],
        magnetometerData:                            ["e95dfb11-251d-470a-a062-fa1922dfa9a8", "ç£åŠ›è¨ˆæ•¸æ“š"],
        magnetometerPeriod:                          ["e95d386c-251d-470a-a062-fa1922dfa9a8", "ç£åŠ›è¨ˆé€±æœŸ"],
        magnetometerBearing:                         ["e95d9715-251d-470a-a062-fa1922dfa9a8", "ç£åŠ›è¨ˆæ–¹ä½"],
        magnetometerCalibration:                     ["e95db358-251d-470a-a062-fa1922dfa9a8", "ç£åŠ›è¨ˆæ ¡æº–"],
        buttonAState:                                ["e95dda90-251d-470a-a062-fa1922dfa9a8", "æŒ‰éˆ•Aç‹€æ…‹"],
        buttonBState:                                ["e95dda91-251d-470a-a062-fa1922dfa9a8", "æŒ‰éˆ•Bç‹€æ…‹"],
        pinData:                                     ["e95d8d00-251d-470a-a062-fa1922dfa9a8", "å¼•è…³æ•¸æ“š"],
        pinADConfiguration:                          ["e95d5899-251d-470a-a062-fa1922dfa9a8", "å¼•è…³ADé…ç½®"],
        pinIOConfiguration:                          ["e95db9fe-251d-470a-a062-fa1922dfa9a8", "å¼•è…³IOé…ç½®"],
        pwmControl:                                  ["e95dd822-251d-470a-a062-fa1922dfa9a8", "PWMæ§åˆ¶"],
        ledMatrixState:                              ["e95d7b77-251d-470a-a062-fa1922dfa9a8", "LEDçŸ©é™£ç‹€æ…‹"],
        ledText:                                     ["e95d93ee-251d-470a-a062-fa1922dfa9a8", "LEDæ–‡æœ¬"],
        scrollingDelay:                              ["e95d0d2d-251d-470a-a062-fa1922dfa9a8", "æ»¾å‹•å»¶é²"],
        microbitRequirements:                        ["e95db84c-251d-470a-a062-fa1922dfa9a8", "MicroBitéœ€æ±‚"],
        microbitEvent:                               ["e95d9775-251d-470a-a062-fa1922dfa9a8", "MicroBitäº‹ä»¶"],
        clientRequirements:                          ["e95d23c4-251d-470a-a062-fa1922dfa9a8", "å®¢æˆ¶ç«¯éœ€æ±‚"],
        clientEvent:                                 ["e95d5404-251d-470a-a062-fa1922dfa9a8", "å®¢æˆ¶ç«¯äº‹ä»¶"],
        dfuControl:                                  ["e95d93b1-251d-470a-a062-fa1922dfa9a8", "DFUæ§åˆ¶"],
        temperature:                                 ["e95d9250-251d-470a-a062-fa1922dfa9a8", "æº«åº¦"],
        temperaturePeriod:                           ["e95d1b25-251d-470a-a062-fa1922dfa9a8", "æº«åº¦é€±æœŸ"],
        txCharacteristic:                            ["6e400002-b5a3-f393-e0a9-e50e24dcca9e", "ç™¼é€ç‰¹å¾µ"],
        rxCharacteristic:                            ["6e400003-b5a3-f393-e0a9-e50e24dcca9e", "æ¥æ”¶ç‰¹å¾µ"],
        /**
         * åœ¨æ‰€æœ‰æœå‹™å’Œç‰¹å¾µçš„UUIDä¸­æœç´¢UUIDçš„æ–¹æ³•ï¼Œä¸¦è¿”å›:
         * - HTMLè—è‰²é¡¯ç¤ºæ‰¾åˆ°çš„æœå‹™/ç‰¹å¾µçš„åç¨±ã€‚
         * - å¦‚æœæœªæ‰¾åˆ°UUIDï¼Œå‰‡ä»¥HTMLç´…è‰²é¡¯ç¤ºæ¶ˆæ¯ã€‚
         * @param uuid æœå‹™æˆ–ç‰¹å¾µUUIDã€‚
         * @param serviceOrCharacteristic å¦‚æœæ˜¯æœå‹™ï¼Œå‰‡ç‚ºTrueï¼ˆæˆ–1ï¼‰ï¼Œå¦‚æœæ˜¯ç‰¹å¾µï¼Œå‰‡ç‚ºfalseï¼ˆæˆ–0ï¼‰ã€‚
         */
        searchUuid(uuid, serviceOrCharacteristic) {
            for (const key in microbitUuid) {
                if (uuid === microbitUuid[key][0]) {
                    return "<font color='blue'>" + microbitUuid[key][1] + "</font>";
                }
            }
            if (serviceOrCharacteristic) {
                return "<font color='red'>æœªçŸ¥çš„Micro:Bitæœå‹™</font>";
            } else {
                return "<font color='red'>æœªçŸ¥çš„Micro:Bitç‰¹å¾µ</font>";
            }
        },
    };

    var bluetoothDevice;
    var txCharacteristic;
    var rxCharacteristic;
    // var lightState = 0; // These seem unused, can be removed if not needed later
    // var airconState = 0; // These seem unused, can be removed if not needed later
    
    // ç‹€æ…‹è¿½è¹¤
    var pendingStates = {
        lightsensor: true,
        aircon: true,
        lightcontrol: true
    };
    
    var statesData = {
        lightsensor: "Unknown",
        aircon: "Unknown", // Corrected typo from "Unknow" to "Unknown"
        lightcontrol: "Unknown"
    };
    
    // åˆ·æ–°ä¸­æ¨™è¨˜
    var refreshingStates = false;

    /**
     * å°‡å­—ç¬¦ä¸²æ·»åŠ åˆ°æ—¥èªŒçš„å‡½æ•¸ã€‚å¦‚æœnewLineç‚ºtrueï¼Œå‰‡åœ¨å­—ç¬¦ä¸²æœ«å°¾æ·»åŠ æ–°è¡Œã€‚
     * @param string è¦æ‰“å°åˆ°æ—¥èªŒçš„å­—ç¬¦ä¸²ã€‚
     * @param newLine æŒ‡å®šæ˜¯å¦é–‹å§‹æ–°è¡Œçš„å¸ƒçˆ¾å€¼ã€‚
     */
    function addLog(string, newLine) {
        document.getElementById("log").innerHTML += string;
        if (newLine) {
            document.getElementById("log").innerHTML += "<br>";
        }
    }

    /**
     * ä»¥ç²—é«”å’Œç´…è‰²å°‡å­—ç¬¦ä¸²ï¼ˆå’Œæ›è¡Œç¬¦ï¼‰æ·»åŠ åˆ°æ—¥èªŒçš„å‡½æ•¸ã€‚
     * @param string è¦æ‰“å°åˆ°æ—¥èªŒçš„å­—ç¬¦ä¸²ã€‚
     */
    function addLogError(string) {
        addLog("<b><font color='red'>" + string + "</font></b>", true);
    }

    /**
     * æ¸…ç©ºæ—¥èªŒçš„å‡½æ•¸ã€‚
     */
    function clearLog() {
        document.getElementById("log").innerHTML = "";
    }

    /**
     * æ¸…ç©ºUART TXå­—æ®µçš„å‡½æ•¸ã€‚
     */
    function clearTx() {
        document.getElementById("tx").innerHTML = "";
    }

    /**
     * æ–·é–‹é€£æ¥æ™‚å°‡èƒŒæ™¯é¡è‰²è®Šç‚ºç´…è‰²çš„å‡½æ•¸ã€‚
     */
    function onDisconnected() {
        document.getElementById("body").style.backgroundColor = "#FFD0D0";
        addLog("Hub DISCONNECTED.", true);
        
        // é‡ç½®ç‹€æ…‹
        resetStates();
    }
    
    /**
     * é‡ç½®æ‰€æœ‰ç‹€æ…‹
     */
    function resetStates() {
        pendingStates = {
            lightsensor: true,
            aircon: true,
            lightcontrol: true
        };
        
        statesData = {
            lightsensor: "Unknown",
            aircon: "Unknown",
            lightcontrol: "Unknown"
        };
        
        document.getElementById("status_lightsensor_text").innerHTML = "Light Sensorï¼šUnknown"; // Corrected display string
        document.getElementById("status_lightsensor_text").className = "status-pending";
        document.getElementById("status_aircon_text").innerHTML = "ACï¼šUnknown";
        document.getElementById("status_aircon_text").className = "status-pending";
        document.getElementById("status_lightcontrol_text").innerHTML = "LIGHTï¼šUnknown"; // Consistent with other display strings
        document.getElementById("status_lightcontrol_text").className = "status-pending";
        document.getElementById("status_loading").innerHTML = "";
        refreshingStates = false;
    }

    /**
     * æ ¹æ“šUARTç‰¹å¾µæ›´æ–°HTMLå…ƒç´ çš„å‡½æ•¸ã€‚
     */
    function readTx(event) {
        let enc = new TextDecoder("utf-8");
        let value = enc.decode(event.target.value);
        document.getElementById("tx").innerHTML += value + "<br>";
        
        // è™•ç†ç‹€æ…‹æ›´æ–°éŸ¿æ‡‰
        let match;
        
        // å…¼å®¹ä¸¤ç§æ ¼å¼ï¼šå†’å·å’Œç­‰å·
        if ((match = value.match(/lightsensor[=:](\d+)/))) {
            const sensorValue = match[1];
            statesData.lightsensor = sensorValue;
            pendingStates.lightsensor = false;
            updateDisplay();
        } 
        else if ((match = value.match(/aircon[=:](\d+)/))) {
            const airconValue = match[1];
            statesData.aircon = airconValue;
            pendingStates.aircon = false;
            updateDisplay();
        } 
        else if ((match = value.match(/lightcontrol[=:](\d+)/))) {
            const lightValue = match[1];
            statesData.lightcontrol = lightValue;
            pendingStates.lightcontrol = false;
            updateDisplay();
        }
    }
    
    /**
     * æ›´æ–°é¡¯ç¤ºï¼Œåƒ…åœ¨æ‰€æœ‰æ•¸æ“šå‡å·²æ”¶åˆ°æ™‚é¡¯ç¤ºå®Œæ•´ç‹€æ…‹
     */
    function updateDisplay() {
        // æª¢æŸ¥æ˜¯å¦æ­£åœ¨åˆ·æ–°ç‹€æ…‹å’Œæ‰€æœ‰æ•¸æ“šæ˜¯å¦éƒ½å·²æ¥æ”¶
        if (refreshingStates) {
            const allReceived = !pendingStates.lightsensor && 
                                !pendingStates.aircon && 
                                !pendingStates.lightcontrol;
            
            if (allReceived) {
                // æ‰€æœ‰æ•¸æ“šå·²æ¥æ”¶ï¼Œæ›´æ–°é¡¯ç¤º
                document.getElementById("status_loading").innerHTML = "(Done)";
                setTimeout(() => {
                    document.getElementById("status_loading").innerHTML = "";
                }, 2000);
                
                // æ›´æ–°å…‰åº¦æª¢æ¸¬å™¨
                // **FIXED HERE: Use template literals with backticks ``**
                document.getElementById("status_lightsensor_text").innerHTML = `Light Sensorï¼š${statesData.lightsensor}`;
                document.getElementById("status_lightsensor_text").className = "status-complete";
                
                // æ›´æ–°å†·æ°£æ©Ÿ
                const airconStatus = parseInt(statesData.aircon) === 1 ? "On" :"Off";
                // **FIXED HERE: Use template literals with backticks ``**
                document.getElementById("status_aircon_text").innerHTML = `ACï¼š${airconStatus}`;
                document.getElementById("status_aircon_text").className = "status-complete";
                
                // æ›´æ–°ç‡ˆ
                const lightStatus = parseInt(statesData.lightcontrol) === 1 ? "On" : "Off";
                // **FIXED HERE: Use template literals with backticks ``**
                document.getElementById("status_lightcontrol_text").innerHTML = `LIGHTï¼š${lightStatus}`;
                document.getElementById("status_lightcontrol_text").className = "status-complete";
                
                refreshingStates = false;
                addLog("All status data refreshed.", true); // Corrected typo from "refresed"
            }
        }
    }

    /**
     * è¨­ç½®RXæ–‡æœ¬è¼¸å…¥ç‚ºç‰¹å®šå‘½ä»¤ã€‚
     * @param {string} command - è¦åœ¨RXè¼¸å…¥æ¡†ä¸­è¨­ç½®çš„å‘½ä»¤ã€‚
     */
    function setRxText(command) {
        document.getElementById("rxText").value = command;
    }

    /**
     * ä½¿ç”¨ç›¸æ‡‰çš„micro:bitè—ç‰™ç‰¹å¾µæ›´æ–°RXçš„å‡½æ•¸ã€‚
     */
    function writeRx() {
        addLog("æ­£åœ¨å¯«å…¥RX... ", false);
        if (!bluetoothDevice) {
            addLogError("æ²’æœ‰é€£æ¥è¨­å‚™ã€‚");
        } else {
            if (bluetoothDevice.gatt.connected) {
                if (!rxCharacteristic) {
                    addLogError("æ²’æœ‰RXç‰¹å¾µã€‚");
                } else {
                    if (!("TextEncoder" in window)) {
                        addLogError("Sorry, this browser does not support TextEncoder... æŠ±æ­‰ï¼Œæ­¤ç€è¦½å™¨ä¸æ”¯æŒTextEncoder...");
                    } else {
                        let enc = new TextEncoder();
                        rxCharacteristic.writeValue(enc.encode(document.getElementById("rxText").value + '\n'))
                        .then(_ => {
                            addLog("<font color='green'>æˆåŠŸ</font>", true);
                        })
                        .catch(error => {
                            addLogError(error);
                        });
                    }
                }
            } else {
                addLogError("No device connected. æ²’æœ‰é€£æ¥è¨­å‚™ã€‚");
            }
        }
    }

    /**
     * åˆ·æ–°æ‰€æœ‰å‚³æ„Ÿå™¨å’Œæ§åˆ¶çš„ç‹€æ…‹
     */
    function refreshStates() {
        addLog("Refreshing all status... æ­£åœ¨åˆ·æ–°æ‰€æœ‰ç‹€æ…‹...", true);
        
        // é‡ç½®ç‹€æ…‹è¿½è¹¤
        pendingStates = {
            lightsensor: true,
            aircon: true,
            lightcontrol: true
        };
        
        // è¨­ç½®åˆ·æ–°æ¨™è¨˜
        refreshingStates = true;
        
        // é¡¯ç¤ºåŠ è¼‰æŒ‡ç¤ºå™¨
        document.getElementById("status_loading").innerHTML = "ï¼ˆLoading... æ­£åœ¨åŠ è¼‰...ï¼‰";
        document.getElementById("status_lightsensor_text").className = "status-pending";
        document.getElementById("status_aircon_text").className = "status-pending";
        document.getElementById("status_lightcontrol_text").className = "status-pending";
        
        // ç‚ºé˜²æ­¢è«‹æ±‚æ·¹æ²’è¨­å‚™ï¼Œæˆ‘å€‘åœ¨æ¯å€‹è«‹æ±‚ä¹‹é–“è¨­ç½®ä¸€å€‹å¾®å°çš„å»¶é²
        setTimeout(() => getState('lightsensor'), 0);
        setTimeout(() => getState('aircon'), 300);
        setTimeout(() => getState('lightcontrol'), 600);
    }

    /**
     * ç²å–ç‰¹å®šå‚³æ„Ÿå™¨æˆ–æ§åˆ¶çš„ç‹€æ…‹
     * @param {string} what - è¦ç²å–ç‹€æ…‹çš„å‚³æ„Ÿå™¨æˆ–æ§åˆ¶
     */
    function getState(what) {
        if (!bluetoothDevice || !bluetoothDevice.gatt.connected) {
            addLogError("æ²’æœ‰é€£æ¥è¨­å‚™ã€‚");
            return;
        }
        if (!rxCharacteristic) {
            addLogError("æ²’æœ‰RXç‰¹å¾µã€‚");
            return;
        }

        let enc = new TextEncoder();
        // **FIXED HERE: Use template literals with backticks `` for the command string**
        rxCharacteristic.writeValue(enc.encode(`GET ${what}\n`)) 
            .then(_ => {
                // æˆ‘å€‘ä¸éœ€è¦åœ¨é€™è£¡æ›´æ–°UIï¼Œå› ç‚ºéŸ¿æ‡‰å°‡ç”±readTxè™•ç†
                // **FIXED HERE: Use template literals with backticks `` for the log string**
                addLog(`å·²è«‹æ±‚${what}çš„ç‹€æ…‹`, true); 
            })
            .catch(error => {
                addLogError(error);
            });
    }

    /**
     * é€£æ¥åˆ°è—ç‰™è¨­å‚™ä¸¦ä¿å­˜èˆ‡UARTæœå‹™é—œè¯çš„ç‰¹å¾µçš„å‡½æ•¸ã€‚
     */
    function connect() {
        addLog("Requesting micro:bit Bluetooth device... æ­£åœ¨è«‹æ±‚micro:bitè—ç‰™è¨­å‚™... ", false);
        if (!navigator.bluetooth) {
            addLogError("This browser or computer does not support Bluetooth. æ­¤ç€è¦½å™¨æˆ–è¨ˆç®—æ©Ÿä¸æ”¯æŒè—ç‰™ã€‚");
            return;
        }
        
        navigator.bluetooth.requestDevice({
            filters: [{namePrefix: "BBC micro:bit"}],
            optionalServices: [microbitUuid.uartService[0]]
        })
        .then(device => {
            addLog("<font color='green'>æˆåŠŸ</font>", true);
            bluetoothDevice = device;
            addLog("æ­£åœ¨é€£æ¥åˆ°GATTæœå‹™å™¨ï¼ˆåç¨±: <font color='blue'>" + device.name + "</font>, ID: <font color='blue'>" + device.id + "</font>)... ", false);
            device.addEventListener('gattserverdisconnected', onDisconnected);
            document.getElementById("body").style.backgroundColor = "#D0FFD0";
            return device.gatt.connect();
        })
        .then(server => {
            addLog("<font color='green'>æˆåŠŸ</font>", true);
            addLog("æ­£åœ¨ç²å–UARTæœå‹™... ", false);
            return server.getPrimaryService(microbitUuid.uartService[0]);
        })
        .then(service => {
            addLog("<font color='green'>æˆåŠŸ</font>", true);
            
            // ç²å–TXç‰¹å¾µ
            addLog("æ­£åœ¨ç²å–TXç‰¹å¾µ... ", false);
            return service.getCharacteristic(microbitUuid.txCharacteristic[0]) // Added return here
            .then(txChar => {
                addLog("<font color='green'>æˆåŠŸ</font>", true);
                txCharacteristic = txChar;
                addLog("æ­£åœ¨å•Ÿå‹•TXé€šçŸ¥... ", false);
                return txChar.startNotifications()
                .then(_ => {
                    txChar.addEventListener('characteristicvaluechanged', readTx);
                    addLog("<font color='green'>æˆåŠŸ</font>", true);
                    
                    // ç²å–RXç‰¹å¾µ
                    addLog("æ­£åœ¨ç²å–RXç‰¹å¾µ... ", false);
                    return service.getCharacteristic(microbitUuid.rxCharacteristic[0]) // Added return here
                    .then(rxChar => {
                        rxCharacteristic = rxChar;
                        addLog("<font color='green'>æˆåŠŸ</font>", true);
                        
                        // é€£æ¥å¾Œåˆ·æ–°ç‹€æ…‹
                        setTimeout(refreshStates, 1000);
                    })
                    // Removed redundant catch that would be caught by the outer chain
                });
            }); // Removed redundant catch that would be caught by the outer chain
        })
        .catch(error => { // This single catch will handle errors from the entire promise chain
            addLogError(error);
        });
    }

    /**
     * æ–·é–‹èˆ‡è—ç‰™è¨­å‚™çš„é€£æ¥çš„å‡½æ•¸ï¼ˆå¦‚æœå·²é€£æ¥ï¼‰ã€‚
     */
    function disconnect() {
        addLog("æ­£åœ¨æ–·é–‹é€£æ¥... ", false);
        if (!bluetoothDevice) {
            addLogError("æ²’æœ‰é€£æ¥è¨­å‚™ã€‚");
        } else {
            if (bluetoothDevice.gatt.connected) {
                bluetoothDevice.gatt.disconnect();
                // The onDisconnected event listener will handle UI updates and logging
                // So, we don't need to check bluetoothDevice.gatt.connected immediately here for success message
                // It will be logged by onDisconnected
            } else {
                addLogError("æ²’æœ‰é€£æ¥è¨­å‚™ã€‚");
            }
        }
    }
    </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
    <title>Smart Home Control Panel</title>
    <style>
        body { background-color:#FFD0D0; font-family: sans-serif; }
        p, button, input { font-size: 16px; }
        #status_display {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ccc;
            background-color: #f9f9f9;
            border-radius: 5px;
        }
        .loading {
            color: #888;
            font-style: italic;
        }
        .status-complete {
            font-weight: bold;
            color: #008800;
        }
        .status-pending {
            color: #888;
        }
    </style>
</head>
<body id="body">

    <h1>Smart Home Control Panel</h1>
    <p>
        Welcome back, please connect your hub first.
    </p>

    <button onclick="connect()">Connect to hub</button>
    <button onclick="disconnect()">Disconnect from hub</button>

    <br><br>
    <div id="status_display">
        <h3>HOME STATUSğŸ¡<span id="status_loading" class="loading"></span></h3>
        <p id="status_lightsensor_text" class="status-pending">Light Sensorï¼šUnknown</p>
        <p id="status_autolighting_text" class="status-pending">AUTO LIGHTINGï¼šUnknown</p>
        <p id="status_lightcontrol_text" class="status-pending">LIGHTï¼šUnknown</p>
    </div>

    <p>Light ğŸ’¡</p>
    <p>
    <button onclick="setRxText('SET lightcontrol 1')">TURN ONğŸ”›</button>
    <button onclick="setRxText('SET lightcontrol 0')">TURN OFF ğŸ“´</button>
    </p>
    
    <p>Auto Lighting ğŸ’¡</p>
    <p>
    <button onclick="setRxText('SET AUTOLIGHT')">TURN ONğŸ”›</button> 
    </p>
    
    <h2>Transmitting Area</h2>
    <input type="text" id="rxText" maxlength="19">
    <button onclick="writeRx()">CONFIRM COMMAND</button>
    
    <br>
    <button onclick="refreshStates()">Refresh Status</button>

    <h2>Received Data<button onclick="clearTx()">ClearğŸ—‘ï¸</button></h2>
    <p id="tx" style="font-family:'Courier New',Courier,monospace"></p>

    <h2>log <button onclick="clearLog()">ClearğŸ—‘ï¸</button></h2>
    <p id="log" style="font-family:'Courier New',Courier,monospace"></p>

    <script>
    /**
     * åŒ…å«micro:bitæ‰€æœ‰æœå‹™å’Œç‰¹å¾µçš„è—ç‰™UUIDçš„å°è±¡
     */
    var microbitUuid = {
        /**
         * æœå‹™
         */
        genericAccess:                             ["00001800-0000-1000-8000-00805f9b34fb", "ä¸€èˆ¬è¨ªå•"],
        genericAttribute:                            ["00001801-0000-1000-8000-00805f9b34fb", "ä¸€èˆ¬å±¬æ€§"],
        deviceInformation:                           ["0000180a-0000-1000-8000-00805f9b34fb", "è¨­å‚™ä¿¡æ¯"],
        accelerometerService:                        ["e95d0753-251d-470a-a062-fa1922dfa9a8", "åŠ é€Ÿåº¦è¨ˆæœå‹™"],
        magnetometerService:                         ["e95df2d8-251d-470a-a062-fa1922dfa9a8", "ç£åŠ›è¨ˆæœå‹™"],
        buttonService:                               ["e95d9882-251d-470a-a062-fa1922dfa9a8", "æŒ‰éˆ•æœå‹™"],
        ioPinService:                                ["e95d127b-251d-470a-a062-fa1922dfa9a8", "IOå¼•è…³æœå‹™"],
        ledService:                                  ["e95dd91d-251d-470a-a062-fa1922dfa9a8", "LEDæœå‹™"],
        eventService:                                ["e95d93af-251d-470a-a062-fa1922dfa9a8", "äº‹ä»¶æœå‹™"],
        dfuControlService:                           ["e95d93b0-251d-470a-a062-fa1922dfa9a8", "DFUæ§åˆ¶æœå‹™"],
        temperatureService:                          ["e95d6100-251d-470a-a062-fa1922dfa9a8", "æº«åº¦æœå‹™"],
        uartService:                                 ["6e400001-b5a3-f393-e0a9-e50e24dcca9e", "UARTæœå‹™"],
        /**
         * ç‰¹å¾µ
         */
        deviceName:                                  ["00002a00-0000-1000-8000-00805f9b34fb", "è¨­å‚™åç¨±"],
        appearance:                                  ["00002a01-0000-1000-8000-00805f9b34fb", "å¤–è§€"],
        peripheralPreferredConnectionParameters:     ["00002a04-0000-1000-8000-00805f9b34fb", "å¤–è¨­é¦–é¸é€£æ¥åƒæ•¸"],
        serviceChanged:                              ["00002a05-0000-1000-8000-00805f9b34fb", "æœå‹™å·²æ›´æ”¹"],
        modelNumberString:                           ["00002a24-0000-1000-8000-00805f9b34fb", "å‹è™Ÿå­—ç¬¦ä¸²"],
        serialNumberString:                          ["00002a25-0000-1000-8000-00805f9b34fb", "åºåˆ—è™Ÿå­—ç¬¦ä¸²"],
        hardwareRevisionString:                      ["00002a27-0000-1000-8000-00805f9b34fb", "ç¡¬ä»¶ç‰ˆæœ¬å­—ç¬¦ä¸²"],
        firmwareRevisionString:                      ["00002a26-0000-1000-8000-00805f9b34fb", "å›ºä»¶ç‰ˆæœ¬å­—ç¬¦ä¸²"],
        manufacturerNameString:                      ["00002a29-0000-1000-8000-00805f9b34fb", "è£½é€ å•†åç¨±å­—ç¬¦ä¸²"],
        accelerometerData:                           ["e95dca4b-251d-470a-a062-fa1922dfa9a8", "åŠ é€Ÿåº¦è¨ˆæ•¸æ“š"],
        accelerometerPeriod:                         ["e95dfb24-251d-470a-a062-fa1922dfa9a8", "åŠ é€Ÿåº¦è¨ˆé€±æœŸ"],
        magnetometerData:                            ["e95dfb11-251d-470a-a062-fa1922dfa9a8", "ç£åŠ›è¨ˆæ•¸æ“š"],
        magnetometerPeriod:                          ["e95d386c-251d-470a-a062-fa1922dfa9a8", "ç£åŠ›è¨ˆé€±æœŸ"],
        magnetometerBearing:                         ["e95d9715-251d-470a-a062-fa1922dfa9a8", "ç£åŠ›è¨ˆæ–¹ä½"],
        magnetometerCalibration:                     ["e95db358-251d-470a-a062-fa1922dfa9a8", "ç£åŠ›è¨ˆæ ¡æº–"],
        buttonAState:                                ["e95dda90-251d-470a-a062-fa1922dfa9a8", "æŒ‰éˆ•Aç‹€æ…‹"],
        buttonBState:                                ["e95dda91-251d-470a-a062-fa1922dfa9a8", "æŒ‰éˆ•Bç‹€æ…‹"],
        pinData:                                     ["e95d8d00-251d-470a-a062-fa1922dfa9a8", "å¼•è…³æ•¸æ“š"],
        pinADConfiguration:                          ["e95d5899-251d-470a-a062-fa1922dfa9a8", "å¼•è…³ADé…ç½®"],
        pinIOConfiguration:                          ["e95db9fe-251d-470a-a062-fa1922dfa9a8", "å¼•è…³IOé…ç½®"],
        pwmControl:                                  ["e95dd822-251d-470a-a062-fa1922dfa9a8", "PWMæ§åˆ¶"],
        ledMatrixState:                              ["e95d7b77-251d-470a-a062-fa1922dfa9a8", "LEDçŸ©é™£ç‹€æ…‹"],
        ledText:                                     ["e95d93ee-251d-470a-a062-fa1922dfa9a8", "LEDæ–‡æœ¬"],
        scrollingDelay:                              ["e95d0d2d-251d-470a-a062-fa1922dfa9a8", "æ»¾å‹•å»¶é²"],
        microbitRequirements:                        ["e95db84c-251d-470a-a062-fa1922dfa9a8", "MicroBitéœ€æ±‚"],
        microbitEvent:                               ["e95d9775-251d-470a-a062-fa1922dfa9a8", "MicroBitäº‹ä»¶"],
        clientRequirements:                          ["e95d23c4-251d-470a-a062-fa1922dfa9a8", "å®¢æˆ¶ç«¯éœ€æ±‚"],
        clientEvent:                                 ["e95d5404-251d-470a-a062-fa1922dfa9a8", "å®¢æˆ¶ç«¯äº‹ä»¶"],
        dfuControl:                                  ["e95d93b1-251d-470a-a062-fa1922dfa9a8", "DFUæ§åˆ¶"],
        temperature:                                 ["e95d9250-251d-470a-a062-fa1922dfa9a8", "æº«åº¦"],
        temperaturePeriod:                           ["e95d1b25-251d-470a-a062-fa1922dfa9a8", "æº«åº¦é€±æœŸ"],
        txCharacteristic:                            ["6e400002-b5a3-f393-e0a9-e50e24dcca9e", "ç™¼é€ç‰¹å¾µ"],
        rxCharacteristic:                            ["6e400003-b5a3-f393-e0a9-e50e24dcca9e", "æ¥æ”¶ç‰¹å¾µ"],
        /**
         * åœ¨æ‰€æœ‰æœå‹™å’Œç‰¹å¾µçš„UUIDä¸­æœç´¢UUIDçš„æ–¹æ³•ï¼Œä¸¦è¿”å›:
         * - HTMLè—è‰²é¡¯ç¤ºæ‰¾åˆ°çš„æœå‹™/ç‰¹å¾µçš„åç¨±ã€‚
         * - å¦‚æœæœªæ‰¾åˆ°UUIDï¼Œå‰‡ä»¥HTMLç´…è‰²é¡¯ç¤ºæ¶ˆæ¯ã€‚
         * @param uuid æœå‹™æˆ–ç‰¹å¾µUUIDã€‚
         * @param serviceOrCharacteristic å¦‚æœæ˜¯æœå‹™ï¼Œå‰‡ç‚ºTrueï¼ˆæˆ–1ï¼‰ï¼Œå¦‚æœæ˜¯ç‰¹å¾µï¼Œå‰‡ç‚ºfalseï¼ˆæˆ–0ï¼‰ã€‚
         */
        searchUuid(uuid, serviceOrCharacteristic) {
            for (const key in microbitUuid) {
                if (uuid === microbitUuid[key][0]) {
                    return `<font color='blue'>${microbitUuid[key][1]}</font>`;
                }
            }
            if (serviceOrCharacteristic) {
                return "<font color='red'>æœªçŸ¥çš„Micro:Bitæœå‹™</font>";
            } else {
                return "<font color='red'>æœªçŸ¥çš„Micro:Bitç‰¹å¾µ</font>";
            }
        },
    };

    var bluetoothDevice;
    var txCharacteristic;
    var rxCharacteristic;
    
    // ç‹€æ…‹è¿½è¹¤
    var pendingStates = {
        lightsensor: true,
        autolighting: true,
        lightcontrol: true
    };
    
    var statesData = {
        lightsensor: "Unknown",
        autolighting: "Unknown", 
        lightcontrol: "Unknown"
    };
    
    // åˆ·æ–°ä¸­æ¨™è¨˜
    var refreshingStates = false;

    function addLog(string, newLine) {
        document.getElementById("log").innerHTML += string;
        if (newLine) {
            document.getElementById("log").innerHTML += "<br>";
        }
    }

    function addLogError(string) {
        addLog(`<b><font color='red'>${string}</font></b>`, true);
    }

    function clearLog() {
        document.getElementById("log").innerHTML = "";
    }

    function clearTx() {
        document.getElementById("tx").innerHTML = "";
    }

    function onDisconnected() {
        document.getElementById("body").style.backgroundColor = "#FFD0D0";
        addLog("Hub DISCONNECTED.", true);
        resetStates();
    }
    
    function resetStates() {
        pendingStates = {
            lightsensor: true,
            autolighting: true,
            lightcontrol: true
        };
        
        statesData = {
            lightsensor: "Unknown",
            autolighting: "Unknown",
            lightcontrol: "Unknown"
        };
        
        document.getElementById("status_lightsensor_text").innerHTML = "Light Sensorï¼šUnknown";
        document.getElementById("status_lightsensor_text").className = "status-pending";
        // **** FIXED LABEL CONSISTENCY ****
        document.getElementById("status_autolighting_text").innerHTML = "AUTO LIGHTINGï¼šUnknown"; 
        document.getElementById("status_autolighting_text").className = "status-pending";
        document.getElementById("status_lightcontrol_text").innerHTML = "LIGHTï¼šUnknown"; 
        document.getElementById("status_lightcontrol_text").className = "status-pending";
        document.getElementById("status_loading").innerHTML = "";
        refreshingStates = false;
    }

    function readTx(event) {
        let enc = new TextDecoder("utf-8");
        let value = enc.decode(event.target.value);
        document.getElementById("tx").innerHTML += value + "<br>";
        
        let match;
        
        if ((match = value.match(/lightsensor[=:](\d+)/i))) { // Added i for case-insensitivity if microbit varies
            statesData.lightsensor = match[1];
            pendingStates.lightsensor = false;
            updateDisplay();
        } 
        else if ((match = value.match(/autolighting[=:](\d+)/i))) {
            statesData.autolighting = match[1];
            pendingStates.autolighting = false;
            updateDisplay();
        } 
        else if ((match = value.match(/lightcontrol[=:](\d+)/i))) {
            statesData.lightcontrol = match[1];
            pendingStates.lightcontrol = false;
            updateDisplay();
        }
    }
    
    function updateDisplay() {
        if (refreshingStates) {
            const allReceived = !pendingStates.lightsensor && 
                                  !pendingStates.autolighting && 
                                  !pendingStates.lightcontrol;
            
            if (allReceived) {
                document.getElementById("status_loading").innerHTML = "(Done)";
                setTimeout(() => {
                    document.getElementById("status_loading").innerHTML = "";
                }, 2000);
                
                document.getElementById("status_lightsensor_text").innerHTML = `Light Sensorï¼š${statesData.lightsensor}`;
                document.getElementById("status_lightsensor_text").className = "status-complete";
                
                const autolightingStatus = parseInt(statesData.autolighting) === 0 ? "On" :"Off"; // Assuming 0 is ON for autolighting (mancontrol=0)
                document.getElementById("status_autolighting_text").innerHTML = `Auto Lightingï¼š${autolightingStatus}`;
                document.getElementById("status_autolighting_text").className = "status-complete";
                
                const lightStatus = parseInt(statesData.lightcontrol) === 1 ? "On" : "Off";
                document.getElementById("status_lightcontrol_text").innerHTML = `LIGHTï¼š${lightStatus}`;
                document.getElementById("status_lightcontrol_text").className = "status-complete";
                
                refreshingStates = false;
                addLog("All status data refreshed.", true);
            }
        }
    }

    function setRxText(command) {
        document.getElementById("rxText").value = command;
    }

    function writeRx() {
        addLog("æ­£åœ¨å¯«å…¥RX... ", false);
        if (!bluetoothDevice) {
            addLogError("æ²’æœ‰é€£æ¥è¨­å‚™ã€‚");
            return;
        }
        if (!bluetoothDevice.gatt.connected) {
            addLogError("No device connected. æ²’æœ‰é€£æ¥è¨­å‚™ã€‚");
            return;
        }
        if (!rxCharacteristic) {
            addLogError("æ²’æœ‰RXç‰¹å¾µã€‚");
            return;
        }
        if (!("TextEncoder" in window)) {
            addLogError("Sorry, this browser does not support TextEncoder... æŠ±æ­‰ï¼Œæ­¤ç€è¦½å™¨ä¸æ”¯æŒTextEncoder...");
            return;
        }
        
        let enc = new TextEncoder();
        rxCharacteristic.writeValue(enc.encode(document.getElementById("rxText").value + '\n'))
        .then(_ => {
            addLog("<font color='green'>æˆåŠŸ</font>", true);
        })
        .catch(error => {
            addLogError(error);
        });
    }

    function refreshStates() {
        addLog("Refreshing all status... æ­£åœ¨åˆ·æ–°æ‰€æœ‰ç‹€æ…‹...", true);
        
        pendingStates = {
            lightsensor: true,
            autolighting: true,
            lightcontrol: true
        };
        
        refreshingStates = true;
        
        document.getElementById("status_loading").innerHTML = "ï¼ˆLoading... æ­£åœ¨åŠ è¼‰...ï¼‰";
        document.getElementById("status_lightsensor_text").className = "status-pending";
        document.getElementById("status_autolighting_text").className = "status-pending";
        document.getElementById("status_lightcontrol_text").className = "status-pending";
        
        setTimeout(() => getState('lightsensor'), 0);
        setTimeout(() => getState('autolighting'), 300); // Ensure micro:bit handles GET autolighting
        setTimeout(() => getState('lightcontrol'), 600);
    }

    function getState(what) {
        if (!bluetoothDevice || !bluetoothDevice.gatt.connected) {
            addLogError("æ²’æœ‰é€£æ¥è¨­å‚™ã€‚");
            refreshingStates = false; // Stop refresh attempt
            document.getElementById("status_loading").innerHTML = "(Error)";
            return;
        }
        if (!rxCharacteristic) {
            addLogError("æ²’æœ‰RXç‰¹å¾µã€‚");
            refreshingStates = false; // Stop refresh attempt
            document.getElementById("status_loading").innerHTML = "(Error)";
            return;
        }

        let enc = new TextEncoder();
        // Ensure micro:bit expects these exact GET command strings
        rxCharacteristic.writeValue(enc.encode(`GET ${what}\n`)) 
        .then(_ => {
            addLog(`å·²è«‹æ±‚${what}çš„ç‹€æ…‹`, true); 
        })
        .catch(error => {
            addLogError(error);
            pendingStates[what] = false; // Don't wait for this state indefinitely if send fails
            updateDisplay(); // Try to update with what we have
        });
    }

    function connect() {
        addLog("Requesting micro:bit Bluetooth device... æ­£åœ¨è«‹æ±‚micro:bitè—ç‰™è¨­å‚™... ", false);
        if (!navigator.bluetooth) {
            addLogError("This browser or computer does not support Bluetooth. æ­¤ç€è¦½å™¨æˆ–è¨ˆç®—æ©Ÿä¸æ”¯æŒè—ç‰™ã€‚");
            return;
        }
        
        navigator.bluetooth.requestDevice({
            filters: [{namePrefix: "BBC micro:bit"}],
            optionalServices: [microbitUuid.uartService[0]]
        })
        .then(device => {
            addLog("<font color='green'>æˆåŠŸ</font>", true);
            bluetoothDevice = device;
            addLog(`æ­£åœ¨é€£æ¥åˆ°GATTæœå‹™å™¨ï¼ˆåç¨±: <font color='blue'>${device.name}</font>, ID: <font color='blue'>${device.id}</font>)... `, false);
            device.addEventListener('gattserverdisconnected', onDisconnected);
            document.getElementById("body").style.backgroundColor = "#D0FFD0";
            return device.gatt.connect();
        })
        .then(server => {
            addLog("<font color='green'>æˆåŠŸ</font>", true);
            addLog("æ­£åœ¨ç²å–UARTæœå‹™... ", false);
            return server.getPrimaryService(microbitUuid.uartService[0]);
        })
        .then(service => {
            addLog("<font color='green'>æˆåŠŸ</font>", true);
            
            addLog("æ­£åœ¨ç²å–TXç‰¹å¾µ... ", false);
            return service.getCharacteristic(microbitUuid.txCharacteristic[0])
            .then(txChar => {
                addLog("<font color='green'>æˆåŠŸ</font>", true);
                txCharacteristic = txChar;
                addLog("æ­£åœ¨å•Ÿå‹•TXé€šçŸ¥... ", false);
                return txChar.startNotifications()
                .then(_ => {
                    txChar.addEventListener('characteristicvaluechanged', readTx);
                    addLog("<font color='green'>æˆåŠŸ</font>", true);
                    
                    addLog("æ­£åœ¨ç²å–RXç‰¹å¾µ... ", false);
                    return service.getCharacteristic(microbitUuid.rxCharacteristic[0])
                    .then(rxChar => {
                        rxCharacteristic = rxChar;
                        addLog("<font color='green'>æˆåŠŸ</font>", true);
                        
                        setTimeout(refreshStates, 1000); // Refresh status after successful connection
                    });
                });
            });
        })
        .catch(error => { 
            addLogError(error);
            document.getElementById("body").style.backgroundColor = "#FFD0D0"; // Revert color on connection error
        });
    }

    function disconnect() {
        addLog("æ­£åœ¨æ–·é–‹é€£æ¥... ", false);
        if (!bluetoothDevice) {
            addLogError("æ²’æœ‰é€£æ¥è¨­å‚™ã€‚");
            return;
        }
        if (bluetoothDevice.gatt.connected) {
            bluetoothDevice.gatt.disconnect();
            // onDisconnected will handle UI updates
        } else {
            addLogError("æ²’æœ‰é€£æ¥è¨­å‚™ã€‚");
        }
    }
    </script>
</body>
</html>
